Lex File — icg_full.l

%{
#include "y.tab.h"
%}

%%
[0-9]+          { yylval = strdup(yytext); return NUM; }
[a-zA-Z][a-zA-Z0-9]*  { yylval = strdup(yytext); return ID; }
"="             { return ASSIGN; }
[+\-*/()]       { return yytext[0]; }
[ \t\n]         ;   // ignore whitespace
.               ;
%%

int yywrap() { return 1; }



Yacc File — icg_full.y


%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int tempCount = 0;

char* newTemp() {
    char *temp = (char*)malloc(5);
    sprintf(temp, "t%d", tempCount++);
    return temp;
}
%}

%union {
    char *str;
}

%token <str> ID NUM
%token ASSIGN
%left '+' '-'
%left '*' '/'
%type <str> expr stmt

%%
stmt:
      expr { printf("Final Result in %s\n", $1); }
    | ID ASSIGN expr { printf("%s = %s\n", $1, $3); }
    ;

expr:
      NUM {
            char *t = newTemp();
            printf("%s = %s\n", t, $1);
            $$ = t;
          }
    | ID {
            char *t = newTemp();
            printf("%s = %s\n", t, $1);
            $$ = t;
          }
    | expr '+' expr {
            char *t = newTemp();
            printf("%s = %s + %s\n", t, $1, $3);
            $$ = t;
          }
    | expr '-' expr {
            char *t = newTemp();
            printf("%s = %s - %s\n", t, $1, $3);
            $$ = t;
          }
    | expr '*' expr {
            char *t = newTemp();
            printf("%s = %s * %s\n", t, $1, $3);
            $$ = t;
          }
    | expr '/' expr {
            char *t = newTemp();
            printf("%s = %s / %s\n", t, $1, $3);
            $$ = t;
          }
    | '(' expr ')' { $$ = $2; }
    ;
%%

int main() {
    printf("Enter expression (e.g., 2+4*3 or a=b+c*d):\n");
    yyparse();
    return 0;
}

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}



lex icg_full.l
yacc -d icg_full.y
gcc lex.yy.c y.tab.c -o icg_full
./icg_full